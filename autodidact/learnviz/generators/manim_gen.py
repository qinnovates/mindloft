"""
Manim Code Generator

Generates Manim Python code from visualization plans.
Includes templates for common educational patterns.
"""

import json
from typing import Dict, Any, List, Optional
from pathlib import Path


class ManimTemplate:
    """Base class for Manim templates."""

    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description

    def generate(self, params: Dict[str, Any]) -> str:
        raise NotImplementedError


class BinarySearchTemplate(ManimTemplate):
    """Template for binary search visualization."""

    def __init__(self):
        super().__init__(
            "binary_search",
            "Visualize binary search algorithm step by step"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        array = params.get("array", [1, 3, 5, 7, 9, 11, 13, 15, 17, 19])
        target = params.get("target", 7)

        return f'''"""
Binary Search Visualization
Generated by LearnViz
"""
from manim import *

class BinarySearchScene(Scene):
    def construct(self):
        # Configuration
        array = {array}
        target = {target}

        # Title
        title = Text("Binary Search Algorithm", font_size=48)
        subtitle = Text(f"Finding {{target}} in a sorted array", font_size=24)
        subtitle.next_to(title, DOWN)

        self.play(Write(title))
        self.play(FadeIn(subtitle))
        self.wait(1)
        self.play(FadeOut(title), FadeOut(subtitle))

        # Create array visualization
        boxes = VGroup()
        numbers = VGroup()
        indices = VGroup()

        for i, val in enumerate(array):
            box = Square(side_length=0.8)
            box.set_stroke(WHITE, 2)
            num = Text(str(val), font_size=24)
            idx = Text(str(i), font_size=16, color=GRAY)

            if i > 0:
                box.next_to(boxes[-1], RIGHT, buff=0.1)

            num.move_to(box.get_center())
            idx.next_to(box, DOWN, buff=0.1)

            boxes.add(box)
            numbers.add(num)
            indices.add(idx)

        array_group = VGroup(boxes, numbers, indices)
        array_group.center()

        # Target display
        target_text = Text(f"Target: {{target}}", font_size=32)
        target_text.to_edge(UP)

        self.play(
            Create(boxes),
            Write(numbers),
            Write(indices),
            Write(target_text)
        )
        self.wait(1)

        # Binary search animation
        left, right = 0, len(array) - 1
        step = 1

        # Pointers
        left_arrow = Arrow(start=DOWN, end=UP, color=BLUE).scale(0.5)
        right_arrow = Arrow(start=DOWN, end=UP, color=RED).scale(0.5)
        left_label = Text("L", font_size=20, color=BLUE)
        right_label = Text("R", font_size=20, color=RED)

        left_arrow.next_to(boxes[left], DOWN, buff=0.5)
        right_arrow.next_to(boxes[right], DOWN, buff=0.5)
        left_label.next_to(left_arrow, DOWN, buff=0.1)
        right_label.next_to(right_arrow, DOWN, buff=0.1)

        self.play(
            Create(left_arrow), Write(left_label),
            Create(right_arrow), Write(right_label)
        )

        while left <= right:
            mid = (left + right) // 2

            # Step indicator
            step_text = Text(f"Step {{step}}: Check middle (index {{mid}})", font_size=24)
            step_text.to_edge(DOWN)
            self.play(Write(step_text))

            # Highlight middle
            self.play(boxes[mid].animate.set_fill(YELLOW, opacity=0.5))
            self.wait(0.5)

            if array[mid] == target:
                # Found!
                found_text = Text(f"Found {{target}} at index {{mid}}!", font_size=32, color=GREEN)
                found_text.next_to(step_text, UP)
                self.play(
                    boxes[mid].animate.set_fill(GREEN, opacity=0.7),
                    Write(found_text)
                )
                break
            elif array[mid] < target:
                # Go right
                compare_text = Text(f"{{array[mid]}} < {{target}}, search right half", font_size=20)
                compare_text.next_to(step_text, UP)
                self.play(Write(compare_text))

                # Gray out left half
                for i in range(left, mid + 1):
                    self.play(
                        boxes[i].animate.set_fill(GRAY, opacity=0.3),
                        run_time=0.2
                    )

                left = mid + 1
                left_arrow.generate_target()
                left_arrow.target.next_to(boxes[left] if left < len(array) else boxes[-1], DOWN, buff=0.5)
                left_label.generate_target()
                left_label.target.next_to(left_arrow.target, DOWN, buff=0.1)
                self.play(
                    MoveToTarget(left_arrow),
                    MoveToTarget(left_label)
                )
                self.play(FadeOut(compare_text))
            else:
                # Go left
                compare_text = Text(f"{{array[mid]}} > {{target}}, search left half", font_size=20)
                compare_text.next_to(step_text, UP)
                self.play(Write(compare_text))

                # Gray out right half
                for i in range(mid, right + 1):
                    self.play(
                        boxes[i].animate.set_fill(GRAY, opacity=0.3),
                        run_time=0.2
                    )

                right = mid - 1
                right_arrow.generate_target()
                right_arrow.target.next_to(boxes[right] if right >= 0 else boxes[0], DOWN, buff=0.5)
                right_label.generate_target()
                right_label.target.next_to(right_arrow.target, DOWN, buff=0.1)
                self.play(
                    MoveToTarget(right_arrow),
                    MoveToTarget(right_label)
                )
                self.play(FadeOut(compare_text))

            self.play(boxes[mid].animate.set_fill(WHITE, opacity=0))
            self.play(FadeOut(step_text))
            step += 1

        self.wait(2)


if __name__ == "__main__":
    # Render with: manim -pql binary_search.py BinarySearchScene
    pass
'''


class SortingTemplate(ManimTemplate):
    """Template for sorting algorithm visualization."""

    def __init__(self):
        super().__init__(
            "sorting",
            "Visualize sorting algorithms (bubble, selection, insertion)"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        array = params.get("array", [64, 34, 25, 12, 22, 11, 90])
        algorithm = params.get("algorithm", "bubble")

        return f'''"""
{algorithm.title()} Sort Visualization
Generated by LearnViz
"""
from manim import *

class SortingScene(Scene):
    def construct(self):
        array = {array}
        n = len(array)

        # Title
        title = Text("{algorithm.title()} Sort", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Create bars
        bars = self.create_bars(array)
        self.play(Create(bars))
        self.wait(1)

        # Sort with animation
        self.{algorithm}_sort(bars, array)

        # Done
        done_text = Text("Sorted!", font_size=36, color=GREEN)
        done_text.to_edge(DOWN)
        self.play(Write(done_text))
        self.play(bars.animate.set_color(GREEN))
        self.wait(2)

    def create_bars(self, array):
        bars = VGroup()
        max_val = max(array)
        bar_width = 0.8
        spacing = 0.9

        for i, val in enumerate(array):
            height = (val / max_val) * 4
            bar = Rectangle(
                width=bar_width,
                height=height,
                fill_opacity=0.7,
                fill_color=BLUE,
                stroke_color=WHITE
            )
            bar.move_to(
                LEFT * (len(array) / 2 - i) * spacing + DOWN * (2 - height / 2)
            )

            # Value label
            label = Text(str(val), font_size=16)
            label.next_to(bar, UP, buff=0.1)
            bar.label = label

            bars.add(VGroup(bar, label))

        return bars

    def swap_bars(self, bars, i, j):
        bar_i, bar_j = bars[i], bars[j]
        pos_i, pos_j = bar_i.get_center(), bar_j.get_center()

        self.play(
            bar_i.animate.set_color(RED),
            bar_j.animate.set_color(RED),
            run_time=0.3
        )
        self.play(
            bar_i.animate.move_to([pos_j[0], bar_i.get_center()[1], 0]),
            bar_j.animate.move_to([pos_i[0], bar_j.get_center()[1], 0]),
            run_time=0.5
        )
        self.play(
            bar_i.animate.set_color(BLUE),
            bar_j.animate.set_color(BLUE),
            run_time=0.3
        )

        # Swap in list
        bars[i], bars[j] = bars[j], bars[i]

    def bubble_sort(self, bars, array):
        n = len(array)
        for i in range(n):
            for j in range(0, n - i - 1):
                # Highlight comparison
                self.play(
                    bars[j].animate.set_color(YELLOW),
                    bars[j + 1].animate.set_color(YELLOW),
                    run_time=0.2
                )

                if array[j] > array[j + 1]:
                    self.swap_bars(bars, j, j + 1)
                    array[j], array[j + 1] = array[j + 1], array[j]
                else:
                    self.play(
                        bars[j].animate.set_color(BLUE),
                        bars[j + 1].animate.set_color(BLUE),
                        run_time=0.2
                    )

    def selection_sort(self, bars, array):
        n = len(array)
        for i in range(n):
            min_idx = i
            self.play(bars[i].animate.set_color(PURPLE), run_time=0.2)

            for j in range(i + 1, n):
                self.play(bars[j].animate.set_color(YELLOW), run_time=0.1)
                if array[j] < array[min_idx]:
                    if min_idx != i:
                        self.play(bars[min_idx].animate.set_color(BLUE), run_time=0.1)
                    min_idx = j
                    self.play(bars[min_idx].animate.set_color(RED), run_time=0.1)
                else:
                    self.play(bars[j].animate.set_color(BLUE), run_time=0.1)

            if min_idx != i:
                self.swap_bars(bars, i, min_idx)
                array[i], array[min_idx] = array[min_idx], array[i]

            self.play(bars[i].animate.set_color(GREEN), run_time=0.2)

    def insertion_sort(self, bars, array):
        for i in range(1, len(array)):
            key = array[i]
            self.play(bars[i].animate.set_color(YELLOW), run_time=0.2)

            j = i - 1
            while j >= 0 and array[j] > key:
                self.swap_bars(bars, j, j + 1)
                array[j + 1] = array[j]
                j -= 1

            array[j + 1] = key
            self.play(bars[j + 1].animate.set_color(BLUE), run_time=0.2)


if __name__ == "__main__":
    pass
'''


class PythagoreanTemplate(ManimTemplate):
    """Template for Pythagorean theorem proof."""

    def __init__(self):
        super().__init__(
            "pythagorean",
            "Visualize Pythagorean theorem proof"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        return '''"""
Pythagorean Theorem Visualization
Generated by LearnViz
"""
from manim import *

class PythagoreanScene(Scene):
    def construct(self):
        # Title
        title = Text("The Pythagorean Theorem", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Create right triangle
        a, b = 2, 1.5  # sides
        c = np.sqrt(a**2 + b**2)  # hypotenuse

        triangle = Polygon(
            ORIGIN,
            RIGHT * a,
            RIGHT * a + UP * b,
            fill_opacity=0.3,
            fill_color=BLUE,
            stroke_color=WHITE
        )
        triangle.move_to(ORIGIN)

        # Labels
        a_label = MathTex("a").next_to(triangle, DOWN)
        b_label = MathTex("b").next_to(triangle, RIGHT)
        c_label = MathTex("c").move_to(triangle.get_center() + UP * 0.5 + LEFT * 0.5)

        # Right angle marker
        right_angle = RightAngle(
            Line(ORIGIN, RIGHT * a),
            Line(RIGHT * a, RIGHT * a + UP * b),
            length=0.2
        )

        self.play(Create(triangle))
        self.play(Write(a_label), Write(b_label), Write(c_label))
        self.play(Create(right_angle))
        self.wait(1)

        # Create squares on each side
        sq_a = Square(side_length=a, fill_opacity=0.5, fill_color=RED)
        sq_a.next_to(triangle, DOWN, buff=0)

        sq_b = Square(side_length=b, fill_opacity=0.5, fill_color=GREEN)
        sq_b.next_to(triangle, RIGHT, buff=0)

        sq_c = Square(side_length=c, fill_opacity=0.5, fill_color=YELLOW)
        # Position c square on hypotenuse (simplified positioning)
        sq_c.rotate(np.arctan(b/a))
        sq_c.move_to(triangle.get_center() + UP * 1.5 + LEFT * 1)

        # Area labels
        a2_label = MathTex("a^2", color=RED).move_to(sq_a.get_center())
        b2_label = MathTex("b^2", color=GREEN).move_to(sq_b.get_center())
        c2_label = MathTex("c^2", color=YELLOW).move_to(sq_c.get_center())

        self.play(
            Create(sq_a), Write(a2_label),
            Create(sq_b), Write(b2_label),
            run_time=2
        )
        self.wait(1)

        self.play(Create(sq_c), Write(c2_label), run_time=2)
        self.wait(1)

        # Show the equation
        equation = MathTex("a^2", "+", "b^2", "=", "c^2", font_size=56)
        equation.to_edge(DOWN)
        equation[0].set_color(RED)
        equation[2].set_color(GREEN)
        equation[4].set_color(YELLOW)

        self.play(Write(equation))
        self.wait(1)

        # Highlight equation
        box = SurroundingRectangle(equation, color=WHITE, buff=0.2)
        self.play(Create(box))
        self.wait(2)


if __name__ == "__main__":
    pass
'''


class TreeTraversalTemplate(ManimTemplate):
    """Template for binary tree traversal visualization."""

    def __init__(self):
        super().__init__(
            "tree_traversal",
            "Visualize tree traversal (inorder, preorder, postorder)"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        traversal = params.get("traversal", "inorder")
        tree = params.get("tree", [1, 2, 3, 4, 5, 6, 7])

        return f'''"""
Binary Tree {traversal.title()} Traversal
Generated by LearnViz
"""
from manim import *

class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class TreeTraversalScene(Scene):
    def construct(self):
        # Title
        title = Text("{traversal.title()} Traversal", font_size=48)
        self.play(Write(title))
        self.wait(1)
        self.play(title.animate.to_edge(UP).scale(0.6))

        # Build tree from array
        tree_vals = {tree}
        root = self.build_tree(tree_vals)

        # Draw tree
        nodes, edges = self.draw_tree(root)
        self.play(*[Create(e) for e in edges])
        self.play(*[Create(n) for n in nodes.values()])
        self.wait(1)

        # Traversal order display
        order_label = Text("Visit Order: ", font_size=24)
        order_label.to_edge(DOWN).shift(LEFT * 4)
        order_values = VGroup()
        self.play(Write(order_label))

        # Perform traversal
        visited = []
        self.{traversal}_traverse(root, nodes, visited, order_values, order_label)

        self.wait(2)

    def build_tree(self, arr):
        if not arr:
            return None
        nodes = [TreeNode(v) if v is not None else None for v in arr]
        for i, node in enumerate(nodes):
            if node:
                left_idx = 2 * i + 1
                right_idx = 2 * i + 2
                if left_idx < len(nodes):
                    node.left = nodes[left_idx]
                if right_idx < len(nodes):
                    node.right = nodes[right_idx]
        return nodes[0] if nodes else None

    def draw_tree(self, root, x=0, y=2, dx=2, dy=1.5, nodes=None, edges=None, depth=0):
        if nodes is None:
            nodes = {{}}
            edges = []

        if root is None:
            return nodes, edges

        # Create node circle
        circle = Circle(radius=0.4, fill_opacity=0.7, fill_color=BLUE, stroke_color=WHITE)
        label = Text(str(root.val), font_size=24)
        node_group = VGroup(circle, label)
        node_group.move_to([x, y, 0])

        nodes[root.val] = node_group

        # Draw children
        if root.left:
            child_x = x - dx / (depth + 1)
            child_y = y - dy
            edge = Line([x, y - 0.4, 0], [child_x, child_y + 0.4, 0], color=WHITE)
            edges.append(edge)
            self.draw_tree(root.left, child_x, child_y, dx, dy, nodes, edges, depth + 1)

        if root.right:
            child_x = x + dx / (depth + 1)
            child_y = y - dy
            edge = Line([x, y - 0.4, 0], [child_x, child_y + 0.4, 0], color=WHITE)
            edges.append(edge)
            self.draw_tree(root.right, child_x, child_y, dx, dy, nodes, edges, depth + 1)

        return nodes, edges

    def visit_node(self, node, nodes, visited, order_values, order_label):
        if node.val in nodes:
            # Highlight visited
            self.play(nodes[node.val][0].animate.set_fill(GREEN, opacity=0.8), run_time=0.5)

            # Add to order
            val_text = Text(str(node.val), font_size=24, color=GREEN)
            if not visited:
                val_text.next_to(order_label, RIGHT)
            else:
                val_text.next_to(order_values[-1], RIGHT, buff=0.3)
            order_values.add(val_text)
            visited.append(node.val)
            self.play(Write(val_text), run_time=0.3)

    def inorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.inorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.visit_node(node, nodes, visited, order_values, order_label)
        self.inorder_traverse(node.right, nodes, visited, order_values, order_label)

    def preorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.visit_node(node, nodes, visited, order_values, order_label)
        self.preorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.preorder_traverse(node.right, nodes, visited, order_values, order_label)

    def postorder_traverse(self, node, nodes, visited, order_values, order_label):
        if node is None:
            return
        self.postorder_traverse(node.left, nodes, visited, order_values, order_label)
        self.postorder_traverse(node.right, nodes, visited, order_values, order_label)
        self.visit_node(node, nodes, visited, order_values, order_label)


if __name__ == "__main__":
    pass
'''


# Registry of all templates
class ActionPotentialTemplate(ManimTemplate):
    """Template for action potential propagation visualization."""

    def __init__(self):
        super().__init__(
            "action_potential",
            "Visualize action potential propagation along a neuron"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        return '''"""
Action Potential Propagation
Generated by LearnViz

Visualizes how an action potential travels along an axon.
"""
from manim import *
import numpy as np

class ActionPotentialScene(Scene):
    def construct(self):
        # Title
        title = Text("Action Potential Propagation", font_size=42)
        subtitle = Text("How neurons transmit electrical signals", font_size=24, color=GRAY)
        subtitle.next_to(title, DOWN)

        self.play(Write(title))
        self.play(FadeIn(subtitle))
        self.wait(1)
        self.play(FadeOut(title), FadeOut(subtitle))

        # Create neuron structure
        self.show_neuron_structure()
        self.wait(1)

        # Show resting potential
        self.show_resting_potential()
        self.wait(1)

        # Animate action potential
        self.animate_action_potential()
        self.wait(1)

        # Show voltage graph
        self.show_voltage_graph()
        self.wait(2)

    def show_neuron_structure(self):
        # Cell body (soma)
        self.soma = Circle(radius=0.6, fill_opacity=0.7, fill_color=BLUE, stroke_color=WHITE)
        self.soma.shift(LEFT * 5)
        soma_label = Text("Soma", font_size=18).next_to(self.soma, DOWN)

        # Axon (long cylinder representation)
        self.axon = Rectangle(width=8, height=0.4, fill_opacity=0.5, fill_color=BLUE_E, stroke_color=WHITE)
        self.axon.next_to(self.soma, RIGHT, buff=0)

        # Axon terminal
        self.terminal = Circle(radius=0.3, fill_opacity=0.7, fill_color=BLUE, stroke_color=WHITE)
        self.terminal.next_to(self.axon, RIGHT, buff=0)
        terminal_label = Text("Terminal", font_size=18).next_to(self.terminal, DOWN)

        # Myelin sheaths (segments)
        self.myelin_sheaths = VGroup()
        for i in range(4):
            sheath = Rectangle(width=1.5, height=0.6, fill_opacity=0.3, fill_color=YELLOW, stroke_color=YELLOW)
            sheath.move_to(self.axon.get_center() + LEFT * 2.5 + RIGHT * i * 2)
            self.myelin_sheaths.add(sheath)

        myelin_label = Text("Myelin Sheath", font_size=16, color=YELLOW)
        myelin_label.next_to(self.myelin_sheaths[1], UP)

        # Node of Ranvier labels
        node_label = Text("Node of Ranvier", font_size=14, color=RED)
        node_label.next_to(self.axon, UP).shift(LEFT * 1.5)
        node_arrow = Arrow(node_label.get_bottom(), self.axon.get_top() + LEFT * 1.5, color=RED, buff=0.1)

        self.play(
            Create(self.soma), Write(soma_label),
            Create(self.axon),
            Create(self.terminal), Write(terminal_label)
        )
        self.play(
            Create(self.myelin_sheaths),
            Write(myelin_label)
        )
        self.play(Write(node_label), Create(node_arrow))

        # Store for later
        self.neuron_group = VGroup(self.soma, self.axon, self.terminal, self.myelin_sheaths)

    def show_resting_potential(self):
        # Resting potential explanation
        rest_text = Text("Resting Potential: -70mV", font_size=28)
        rest_text.to_edge(UP)

        # Show charge distribution
        plus_outside = VGroup(*[
            Text("+", font_size=20, color=RED).move_to(self.axon.get_top() + UP * 0.3 + LEFT * 3 + RIGHT * i * 1.5)
            for i in range(5)
        ])
        minus_inside = VGroup(*[
            Text("-", font_size=20, color=BLUE).move_to(self.axon.get_center() + LEFT * 3 + RIGHT * i * 1.5)
            for i in range(5)
        ])

        charge_label = Text("+ outside, - inside", font_size=18, color=GRAY)
        charge_label.to_edge(DOWN)

        self.play(Write(rest_text))
        self.play(Write(plus_outside), Write(minus_inside))
        self.play(Write(charge_label))
        self.wait(1)

        self.plus_signs = plus_outside
        self.minus_signs = minus_inside
        self.rest_text = rest_text
        self.charge_label = charge_label

    def animate_action_potential(self):
        # Update title
        ap_text = Text("Action Potential Propagates →", font_size=28, color=YELLOW)
        ap_text.to_edge(UP)
        self.play(Transform(self.rest_text, ap_text))

        # Create propagating wave
        wave = Circle(radius=0.3, fill_opacity=0.8, fill_color=YELLOW, stroke_color=ORANGE)
        wave.move_to(self.soma.get_center())

        self.play(Create(wave))

        # Animate wave traveling along axon
        path_points = [
            self.soma.get_right(),
            self.axon.get_left() + RIGHT * 2,
            self.axon.get_center(),
            self.axon.get_right() - RIGHT * 2,
            self.terminal.get_left()
        ]

        for i, point in enumerate(path_points):
            # Flash at each position
            flash = Circle(radius=0.5, fill_opacity=0, stroke_color=YELLOW, stroke_width=4)
            flash.move_to(point)

            self.play(
                wave.animate.move_to(point),
                Create(flash),
                run_time=0.5
            )
            self.play(FadeOut(flash), run_time=0.2)

        # Wave reaches terminal
        self.play(
            wave.animate.scale(1.5),
            Flash(self.terminal, color=YELLOW)
        )

        signal_text = Text("Signal transmitted!", font_size=24, color=GREEN)
        signal_text.next_to(self.terminal, UP)
        self.play(Write(signal_text))

        self.wave = wave
        self.signal_text = signal_text

    def show_voltage_graph(self):
        # Clear some elements
        self.play(
            FadeOut(self.plus_signs),
            FadeOut(self.minus_signs),
            FadeOut(self.charge_label),
            FadeOut(self.wave),
            FadeOut(self.signal_text),
            self.neuron_group.animate.shift(UP * 1.5).scale(0.7)
        )

        # Create voltage vs time graph
        axes = Axes(
            x_range=[0, 5, 1],
            y_range=[-80, 50, 20],
            x_length=8,
            y_length=4,
            axis_config={"include_tip": True},
        ).shift(DOWN * 1)

        x_label = Text("Time (ms)", font_size=18).next_to(axes.x_axis, DOWN)
        y_label = Text("Voltage (mV)", font_size=18).next_to(axes.y_axis, LEFT).rotate(90 * DEGREES)

        self.play(Create(axes), Write(x_label), Write(y_label))

        # Action potential curve
        def ap_curve(t):
            if t < 1:
                return -70  # Resting
            elif t < 1.5:
                return -70 + 140 * (t - 1) / 0.5  # Depolarization
            elif t < 2:
                return 40 - 120 * (t - 1.5) / 0.5  # Repolarization
            elif t < 2.5:
                return -80 + 10 * (t - 2) / 0.5  # Hyperpolarization
            else:
                return -70  # Return to resting

        graph = axes.plot(ap_curve, x_range=[0, 4], color=YELLOW)

        # Animate the graph drawing
        self.play(Create(graph), run_time=3)

        # Labels for phases
        phases = [
            ("Resting", 0.5, -70, WHITE),
            ("Depolarization", 1.25, 0, GREEN),
            ("Peak (+40mV)", 1.5, 40, RED),
            ("Repolarization", 1.75, -20, BLUE),
            ("Hyperpolarization", 2.25, -80, PURPLE),
        ]

        for name, x, y, color in phases:
            point = axes.c2p(x, y)
            dot = Dot(point, color=color)
            label = Text(name, font_size=14, color=color)
            label.next_to(dot, UP if y > -50 else DOWN, buff=0.2)
            self.play(Create(dot), Write(label), run_time=0.5)

        self.wait(1)


if __name__ == "__main__":
    # Render with: manim -pql action_potential.py ActionPotentialScene
    pass
'''


class SynapseTemplate(ManimTemplate):
    """Template for synaptic transmission visualization."""

    def __init__(self):
        super().__init__(
            "synapse",
            "Visualize neurotransmitter release at a synapse"
        )

    def generate(self, params: Dict[str, Any]) -> str:
        return '''"""
Synaptic Transmission
Generated by LearnViz

Visualizes how signals cross from one neuron to another.
"""
from manim import *

class SynapseScene(Scene):
    def construct(self):
        # Title
        title = Text("Synaptic Transmission", font_size=42)
        subtitle = Text("How neurons communicate", font_size=24, color=GRAY)
        subtitle.next_to(title, DOWN)

        self.play(Write(title))
        self.play(FadeIn(subtitle))
        self.wait(1)
        self.play(FadeOut(title), FadeOut(subtitle))

        # Create synapse structure
        self.create_synapse()
        self.wait(1)

        # Animate signal arrival
        self.signal_arrives()
        self.wait(0.5)

        # Vesicle release
        self.release_neurotransmitters()
        self.wait(0.5)

        # Receptor binding
        self.receptor_binding()
        self.wait(2)

    def create_synapse(self):
        # Presynaptic terminal (top)
        self.presynaptic = RoundedRectangle(
            width=4, height=2, corner_radius=0.3,
            fill_opacity=0.7, fill_color=BLUE, stroke_color=WHITE
        ).shift(UP * 2)
        pre_label = Text("Presynaptic Terminal", font_size=18).next_to(self.presynaptic, UP)

        # Vesicles inside presynaptic
        self.vesicles = VGroup()
        for i in range(6):
            vesicle = Circle(radius=0.15, fill_opacity=0.8, fill_color=YELLOW, stroke_color=ORANGE)
            vesicle.move_to(self.presynaptic.get_center() + UP * 0.3 + LEFT * 0.8 + RIGHT * i * 0.3)
            self.vesicles.add(vesicle)

        # Synaptic cleft (gap)
        self.cleft = Rectangle(
            width=4.5, height=0.8,
            fill_opacity=0.2, fill_color=WHITE, stroke_color=GRAY
        )
        cleft_label = Text("Synaptic Cleft", font_size=16, color=GRAY).next_to(self.cleft, LEFT)

        # Postsynaptic membrane (bottom)
        self.postsynaptic = RoundedRectangle(
            width=4, height=1.5, corner_radius=0.3,
            fill_opacity=0.7, fill_color=GREEN, stroke_color=WHITE
        ).shift(DOWN * 2)
        post_label = Text("Postsynaptic Neuron", font_size=18).next_to(self.postsynaptic, DOWN)

        # Receptors on postsynaptic membrane
        self.receptors = VGroup()
        for i in range(5):
            receptor = Rectangle(width=0.2, height=0.4, fill_opacity=0.8, fill_color=RED, stroke_color=WHITE)
            receptor.move_to(self.postsynaptic.get_top() + LEFT * 1 + RIGHT * i * 0.5)
            self.receptors.add(receptor)

        receptor_label = Text("Receptors", font_size=14, color=RED).next_to(self.receptors, RIGHT)

        self.play(
            Create(self.presynaptic), Write(pre_label),
            Create(self.vesicles)
        )
        self.play(Create(self.cleft), Write(cleft_label))
        self.play(
            Create(self.postsynaptic), Write(post_label),
            Create(self.receptors), Write(receptor_label)
        )

    def signal_arrives(self):
        # Action potential arrives
        signal = Text("⚡ Action Potential Arrives!", font_size=24, color=YELLOW)
        signal.to_edge(UP)
        self.play(Write(signal))

        # Flash the presynaptic terminal
        self.play(
            self.presynaptic.animate.set_fill(YELLOW, opacity=0.9),
            Flash(self.presynaptic, color=YELLOW),
            run_time=0.5
        )
        self.play(
            self.presynaptic.animate.set_fill(BLUE, opacity=0.7),
            run_time=0.3
        )

        self.signal_text = signal

    def release_neurotransmitters(self):
        # Update text
        release_text = Text("Vesicles release neurotransmitters", font_size=20, color=ORANGE)
        release_text.to_edge(UP)
        self.play(Transform(self.signal_text, release_text))

        # Vesicles move to membrane and release
        released = VGroup()
        for i, vesicle in enumerate(self.vesicles[:3]):
            # Move vesicle to bottom of presynaptic
            self.play(
                vesicle.animate.move_to(self.presynaptic.get_bottom()),
                run_time=0.3
            )
            # "Release" - create small dots representing neurotransmitters
            for j in range(4):
                nt = Dot(radius=0.05, color=YELLOW)
                nt.move_to(vesicle.get_center())
                released.add(nt)
                target = self.cleft.get_center() + LEFT * 0.5 + RIGHT * j * 0.3 + DOWN * 0.2 * (i + 1)
                self.play(
                    nt.animate.move_to(target),
                    run_time=0.2
                )
            self.play(FadeOut(vesicle), run_time=0.1)

        self.neurotransmitters = released

    def receptor_binding(self):
        # Update text
        bind_text = Text("Neurotransmitters bind to receptors", font_size=20, color=GREEN)
        bind_text.to_edge(UP)
        self.play(Transform(self.signal_text, bind_text))

        # Move neurotransmitters to receptors
        for i, nt in enumerate(self.neurotransmitters[:5]):
            if i < len(self.receptors):
                target = self.receptors[i].get_top()
                self.play(nt.animate.move_to(target), run_time=0.3)
                self.play(self.receptors[i].animate.set_fill(YELLOW, opacity=0.9), run_time=0.2)

        # Signal continues
        continue_text = Text("Signal continues in postsynaptic neuron!", font_size=22, color=GREEN)
        continue_text.next_to(self.postsynaptic, DOWN, buff=0.5)
        self.play(
            self.postsynaptic.animate.set_fill(YELLOW, opacity=0.7),
            Write(continue_text)
        )
        self.play(self.postsynaptic.animate.set_fill(GREEN, opacity=0.7))


if __name__ == "__main__":
    # Render with: manim -pql synapse.py SynapseScene
    pass
'''


# Registry of all templates
TEMPLATES = {
    "binary_search": BinarySearchTemplate(),
    "search_visual": BinarySearchTemplate(),  # alias
    "sorting": SortingTemplate(),
    "sort_visual": SortingTemplate(),  # alias
    "bubble_sort": SortingTemplate(),
    "pythagorean": PythagoreanTemplate(),
    "proof_steps": PythagoreanTemplate(),  # alias
    "tree_traversal": TreeTraversalTemplate(),
    # Neuroscience templates
    "action_potential": ActionPotentialTemplate(),
    "synapse": SynapseTemplate(),
    "neuron_structure": ActionPotentialTemplate(),  # alias - uses same visualization
}


def generate_manim_code(
    plan: Dict[str, Any],
    template_name: Optional[str] = None,
    params: Optional[Dict[str, Any]] = None
) -> str:
    """
    Generate Manim code from a visualization plan.

    Args:
        plan: Visualization plan from analyzer
        template_name: Override template selection
        params: Parameters for template

    Returns:
        Generated Manim Python code
    """
    # Determine template
    template_key = template_name or plan.get("template")

    if template_key and template_key in TEMPLATES:
        template = TEMPLATES[template_key]
        return template.generate(params or {})

    # Fallback: generate generic scene from plan
    return generate_generic_scene(plan)


def generate_generic_scene(plan: Dict[str, Any]) -> str:
    """
    Generate a generic Manim scene when no template matches.
    """
    title = plan.get("title", "Visualization")
    scenes = plan.get("scenes", [])

    scene_methods = []
    for scene in scenes:
        method = f'''
    def scene_{scene["id"]}_{scene["name"]}(self):
        """
        {scene["description"]}
        Duration: {scene["duration"]}s
        """
        # TODO: Implement {scene["name"]}
        text = Text("{scene["description"][:40]}...", font_size=24)
        self.play(Write(text))
        self.wait({scene["duration"]})
        self.play(FadeOut(text))
'''
        scene_methods.append(method)

    scene_calls = "\n        ".join(
        [f"self.scene_{s['id']}_{s['name']}()" for s in scenes]
    )

    return f'''"""
{title}
Generated by LearnViz

This is a template - fill in the scene implementations.
"""
from manim import *

class GeneratedScene(Scene):
    def construct(self):
        # Run all scenes
        {scene_calls}

{"".join(scene_methods)}

if __name__ == "__main__":
    # Render with: manim -pql generated_scene.py GeneratedScene
    pass
'''


# CLI interface
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Available templates:")
        for name, template in TEMPLATES.items():
            print(f"  {name}: {template.description}")
        print("\nUsage: python manim_gen.py <template_name> [params_json]")
        sys.exit(1)

    template_name = sys.argv[1]
    params = json.loads(sys.argv[2]) if len(sys.argv) > 2 else {}

    if template_name not in TEMPLATES:
        print(f"Unknown template: {template_name}")
        sys.exit(1)

    code = TEMPLATES[template_name].generate(params)
    print(code)
